import path from 'node:path';
import { compileFile } from 'pug';
import { outputLog } from './utils.js';
const reflectAncestorsIntoModuleMap = (moduleGraph, compiledModule, ancestors) => {
    ancestors.forEach((ancestor) => {
        const ancestorModules = moduleGraph.getModulesByFile(ancestor);
        const ancestorModule = (ancestorModules && [...ancestorModules][0]) ||
            moduleGraph.createFileOnlyEntry(ancestor);
        ancestorModule.importers.add(compiledModule);
        compiledModule.importedModules.add(ancestorModule);
    });
};
export const compilePug = async (moduleGraph, url, pugPath, options, locals) => {
    const compiledModule = (await moduleGraph.getModuleByUrl(url)) ||
        (await moduleGraph.ensureEntryFromUrl(url));
    if (compiledModule.file !== pugPath) {
        if (compiledModule.file)
            moduleGraph.fileToModulesMap.delete(compiledModule.file);
        compiledModule.file = pugPath;
        moduleGraph.fileToModulesMap.set(pugPath, new Set([compiledModule]));
    }
    if (compiledModule.transformResult)
        return true;
    const map = null;
    try {
        const compiledTemplate = compileFile(pugPath, options);
        const ancestors = compiledTemplate.dependencies;
        if (ancestors.length)
            reflectAncestorsIntoModuleMap(moduleGraph, compiledModule, ancestors);
        const code = compiledTemplate(locals);
        outputLog('info', 'compiled:', path.relative(process.cwd(), pugPath));
        compiledModule.transformResult = { code, map };
    }
    catch (err) {
        if (err instanceof Error)
            return err;
        return false;
    }
    return true;
};
